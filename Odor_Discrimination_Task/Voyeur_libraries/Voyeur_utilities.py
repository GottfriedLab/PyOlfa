'''
Created on Sep 23, 2013
Modified on Jan 2, 2014
Modified on June 24, 2016

Description: Collection of utilities for use by Voyeur program and Voyeur protocols
Version: 1.1

@author: Admir Resulaj
@author: Pei-Ching Chang
'''

from pyface.api import Dialog, ConfirmationDialog, FileDialog, YES, NO, OK, DirectoryDialog, error, warning, information, CANCEL

from configobj import ConfigObj
from shutil import copy2
import os
import time
import inspect
import subprocess


def save_data_file(sourceFile, destination = None, subdirectory = None, user = None, verbose = True):
    """ Function used to save (i.e copy) a data file into a directory of choice after an experimental session
        Parameters: sourceFile   - the path of the file that was generated by the experimental session and that resides
                                    in the local file system.
                    destination  - An optional destination path where to save the file. File name may be included
                                    or not at the end of the path.
                    subdirectory - An optional subdirectory, i.e folder, to add to the destination path. For example,
                                    if the destination path is a folder called "experiments", the subdirectory can be
                                    a child folder of "experiments", named after the experiment type ("behaviour"
                                    for instance).
                    user         - An optional parameter to indicate which user is conducting the experiments.
                                    If supplied, and if no destination is passed, a configuration file is looked
                                    up to retrieve the folder into which the user is usually copying data files.
                                    If no destination and no user is provided, a default directory is looked up
                                    in the configuration file as the default destination of the file to be copied.
                                    Either way, a save as dialog box will appear and the user will have final say.
    """

    # Validate file parameter passed. Also check to see if the path provided is lacking the default .h5 extension
    if not os.path.exists(sourceFile):
        if not os.path.exists(sourceFile+".h5"):
            # Error message if the source file path could not be found in the system
            error(None,"Woah there!\n\n1. Couldn't find the file that you want to copy.\
                    \n2. Check to see if it exists in the file system and the path provided is correct"\
                    , "File Finding Police report")
            return
        else:
            # File exists but has an extension and one was not provided in the path given.
            # Add it to file path descriptor
            sourceFile += ".h5"
#             information(None, "the filename of source provided lacked the \".h5\" extension.\
#                         \n\nA file with the extension was found and presumed to be the source meant"\
#                         ,"Path Police report")

    # Get file extension
    fileExtension = os.path.splitext(sourceFile)[-1]
    # Get the destination file name from the path provided
    destinationFile = os.path.split(sourceFile)[-1]
    destinationFolder = ""

    # If file has no extension, add the default .h5 extension to destination file name
    if fileExtension == "":
        warning(None, "The file you are trying to save has no extension\n\nAdding \".h5\" to the name of destination file"\
                 , ".h5 Extension Police")
        destinationFile = file + ".h5"
    # The file provided has different extension. Display a warning but do nothing.
    elif fileExtension != ".h5":
        warning(None, "Your file to be copied does not have an \".h5\" extension\n\nNo action taken."\
                , "h5 Extension Police")

    # Display confirmation dialog for copying the file
    dlg = ConfirmationDialog(title = "You there!", yes_label = "Yes Please!",
                 no_label = "Nah...", message = "Would you like to copy the data file generated after the session?\
                 \n\nIf you say Nah... and change your mind, you'll have to copy it manually later")

    # Open the dialog GUI
    dlg.open()

    # User provided a destination path
    if destination:
        # Check to see if destination is a file name with an extension.
        destinationExtension = os.path.splitext(destination)[-1]
        if destinationExtension:
            # Is it .h5? If not, warn but don't override.
            if destinationExtension != ".h5":
                warning(None, "Your destination filename does not have an \".h5\" extension\n\nNo action taken."\
                        , "h5 Extension Police")
            destinationFolder, destinationFile = os.path.split(destination)
        # Assume destination is directory since there is no extension.
        else:
            destinationFolder = destination
    # Look up a default destination from the config file since no <destination> parameter was provided.
    else:
        configFile = os.environ.get("Voyeur_config")
        config = ConfigObj(configFile)

        # A user specific folder was provided.
        if user:
            destinationFolder = config['server']['folder']['data']['user']
        # Use default data folder as read from the config file.
        else:
            destinationFolder = config['server']['folder']['data']['default']

    # User provided a subdirectory, i.e subfolder, into which to place the file.
    if subdirectory:
        # The subdirectory provided has common path with the directory provided. Display warning but do nothing.
        if os.path.commonprefix((destination,subdirectory)):
            warning(None, "Friendly warning!\n<subdirectory> parameter provided has a common path with the <destination>\
                     path parameter\n\n1. No action taken.\n2. Check your final destination path to make sure it is what you want"\
                     , "Path Police report")
        destinationFolder = os.path.join(destinationFolder,subdirectory)

    # Path of the destination of file to be copied.
    destinationPath = os.path.join(destinationFolder,destinationFile)

    if dlg.return_code == YES:
        # A file with same name exists.
        if os.path.isfile(destinationPath):
            warning(None, "A file with given path already exists!\n\n1. No action taken\
                        \n2. Make sure to either rename file or choose different folder", "Path Police report")
        # Provided folder does not exist. Make one and inform the user.
        elif not os.path.isdir(destinationFolder):
            information(None, "Making a new folder to put the file into...", "Information Transparency report")
            # TODO: What if this results in an exception? Catch and do something?
            # TODO: Keep track of made directories so we may delete them later
            os.makedirs(os.path.abspath(destinationFolder))
        # The save as dialog box.
        # TODO: change wildcard to current extension wildcard
        dialog = FileDialog(action="save as", title = "Select directory into which the data file will be copied",\
                             wildcard = "*.*", default_directory = destinationFolder, default_filename = destinationFile)  #*.h5|||
    elif dlg.return_code == NO and verbose:
        information(None, "No file was copied.\n\nIf you change your mind, you will have to transfer the data file manually."\
                    , "Information Transparency report")
        return

    dialog.open()

    # User clicked Save and successful input received.
    if dialog.return_code == OK:
        # The actual copying of the file. TODO: See if the copy2 function throws an exception
        copy2(sourceFile, dialog.path)
    # The user clicked Cancel.
    elif dialog.return_code == CANCEL:
        information(None, "No file was copied.\n\nIf you change your mind, you will have to transfer the data file manually."\
            , "Information Transparency report")

    #TODO: update the Voyeur config file after asking user

    return dialog.path

def parse_rig_config(configFilename=''):
    #If no config file was provided as an option, the default is to look for the RIG_CONFIG
    #os environment variable.
    
    if configFilename=='':
        print "No config file specified, looking for default in RIG_CONFIG os variable"
        configFilename = os.environ.get("RIG_CONFIG")
        #if it didnt find it there, it tries the legacy default
        if configFilename < 1:
            print "No RIG_CONFIG os variable"
    
    if os.path.isfile(configFilename)== False:
        print "RIG CONFIGURATION FILE  " + configFilename + " IS NOT PRESENT"
        
    conf = ConfigObj(configFilename)
    rigName = conf['rig_params']['rig_name']
    # get the water valve duration information and make the durations into integers.
    valveDurations = conf['water_durations'][rigName].dict()
    for k,v in valveDurations.iteritems():
        for k2,v2 in valveDurations[k].iteritems():
            valveDurations[k][k2] = int(v2)

    # get the olfactometer information and make the vials integers and the concentrations floats.
    if len(conf['olfactometers']) > 0 :
        olfa1temp = conf['olfactometers']['olfa_1']['vial'].dict()

        olfa1 = {}
        for k, v in olfa1temp.iteritems():
            olfa1[int(k)] = (v[0],float(v[1]))
        
    if len(conf['olfactometers']) > 1 :
        olfa2temp = conf['olfactometers']['olfa_2']['vial'].dict()
        olfa2 = {}
        for k, v in olfa2temp.iteritems():
            olfa2[int(k)] = (v[0],float(v[1]))

        olfas = (olfa1,olfa2)
    else:
        olfas = (olfa1,)

    try:
        micro_manipulators = conf['micro_manipulators']
    except KeyError:
        micro_manipulators = None
    
    serverPaths = conf['serverPaths'].dict() # paths to folders on server. All strings, no processing required.
    localPaths = conf['localPaths'].dict() #paths to local folders (ie save points).

    return {'rigName': rigName,
            'waterValveDurations': valveDurations,
            'olfas': olfas,
            'serverPaths': serverPaths,
            'localPaths': localPaths,
            'configFilename': configFilename,
            'micro_manipulators': micro_manipulators
            }


def find_odor_vial(olfas,desiredOdorString,desiredOdorConc):
    # This method will return the vial number where an odor-concentration pair exists within the olfactometer object that is passed to it.
    #first make a list of all the vial keys that contain the desiredOdorString. 
    #if no desiredOdorConc == -1 it will return all vials containing the odor, regardless of concentration.
    
    if type(desiredOdorString) is not str:
        print 'Cannot find odor, desired odor value is not a string.'
    else:
        desiredOdorString = desiredOdorString.lower() #make lower case for comparison.
    if desiredOdorConc != -1: # if this is true, the method will return all of the vials containing the odor, regardless of concentration.
        desiredOdorConc = float(desiredOdorConc)

    matchKeys = [] 
    matchOlfas = []
    matchValves = []
    olfaIdx = 0

    for olfa in olfas: #go through each olfactometer passed.
        matchKeys.append([k for k, v in olfa.iteritems() if v[0].lower() == desiredOdorString and float(v[1]) == desiredOdorConc]) #keep a list of the matching physical vials
        matchOlfas.append(olfaIdx) # indices of the olfactometers that they are in.

        olfaIdx += 1 # keep track of which olfa you're on.

    return {'key':matchKeys,'olfa':matchOlfas}
    

def get_git_hash(protocol):
    try:
        protocol_path = inspect.getfile(protocol.__class__)
        protocol_dir = os.path.split(protocol_path)[0]
        cmd_st = 'git -C %s log -n 1 --pretty=format:"%%H"' % protocol_dir
        return subprocess.check_output(cmd_st, shell=True)
    except subprocess.CalledProcessError:
        print "WARNING: CANNOT RETRIEVE/STORE GIT HASH FOR PROTOCOL."
        return ''
    
    
    



